\section{Introduction}


Approximate computing is a computing paradigm that is gaining traction in both hardware and software applications, due to potential performance gains combined with lower power consumption. This is further incentivized by the end of Dennard scaling; in the 1970's Dennard  theorized that together with increasingly smaller transistors, other aspects of processors would scale with it, such as power consumption through a lower required supply voltage~\citep{bohr200730}. This is currently falling apart~\citep{esmaeilzadeh2011dark}, and so researchers, hardware designers and programmers are starting to look elsewhere for performance and efficiency gains.

Critical infrastructure and other critical fields can benefit from approximate computing. In simulation and high precision data processing, approximate computing may reduce both time spent on calculations and power consumed. Image processing and recognition done in modern cars for obstacle detection and avoidance may also benefit from lower power draw from computers as well as increased processing speed.

To augment applications that require correct service, a more thorough analysis of how approximate computing techniques affect the dependability of an application is required.

%One limiting factor to the usage of approximate computing is that there is no common method for comparing the reliability of different approximate computing methods. Different techniques may have a different level of inherent reliability, due to achieving performance and energy gains in very different ways. This project aims to investigate how reliability varies within different techniques of approximate computing through fault injection.

This work will focus on measuring the fault tolerance of software implemented approximate computing through faults injected in software. This is due to physical fault injection being a topic that is already extensively covered, and software implemented fault injection allows for a wider range of injected faults. 
A tool that does not require learning a whole new domain-specific language, and that can be implemented in off-the-shelf hardware, is more likely to be used in practice. For that reason this paper focuses on software tools that can be implemented in existing projects.
 
% While previous work focuses on the injection of physical faults(\cite{han2013approximate}), this work will focus on injecting software faults. 

This project aims to quantify fault tolerance in approximate computing programs through fault injection, and to enable the comparison of fault tolerance between different kinds of approximate computing methods.





